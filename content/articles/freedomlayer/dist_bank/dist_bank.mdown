Title: The Trusted Supernode and Distributed Banking
Date: 2015-12-08 12:43
Author: real


## Motivation

Assume a [mesh network](https://en.wikipedia.org/wiki/Mesh_networking) of
computers (nodes), working together to somehow navigate messages efficiently
across the network.

Life is all good, until at some point one computer (Let's call him $x$) starts
sending a lot of messages. He sends so many messages, that other computers have
problem sending and receiving messages. $x$'s use of the network makes it hard
for other users to use the network correctly.

$x$ is Bob's computer. Bob is a cool guy, but is also a pretty heavy network
user. He transfers large video files, and he also has a digital business that
relies on the networking services of the network.

If this was the normal Internet, at this point Bob will get a call from his
[ISP](https://en.wikipedia.org/wiki/Internet_service_provider) representative,
telling him either to stop what he is doing with the internet, or maybe upgrade
his internet package to a business class client.

But Bob's computer, $x$, is part of a mesh network. Mesh networks are not
managed by any central authority, hence there is no ISP to supervise Bob's
network usage.

It would be nice if the network itself could somehow supervise the network
usage of all the computers. If any computer uses too much bandwidth, he will
have to **pay something of value** to the other computers in the network. This
way, every user of the network could use the network as much as he wants, and
pay according to his use.

If we want to use payments in our network, we need to maintain some kind of a
bank: A distributed bank over the mesh network. In this document we discuss an
idea for creating such a bank.


## Requirements for Distributed Banking

Let's be more specific about what we want to acheive with our bank. For every
user $x$, a balance value $v_x$ is stored. $v_x$ is the amount of money that
$x$ owns.

Our bank should be able to perform the following operations **efficiently**:

1. Money Transfer: A user $x$ can send user $y$ amount money $u$ if $u \leq
   v_x$. After the money transfer, $x$'s balance value will be decreased by
   $u$, and $y$'s balance value will increase by $u$.

2. Inquiry: A user $x$ can get his current balance $v_x$.

Assume that there are $n$ nodes on the mesh network. Also assume that the
longest path between two nodes in the network is diam(G). (The
[diameter](https://en.wikipedia.org/wiki/Distance_%28graph_theory%29) of the
network G). Whenever we write "efficiently" in this document, we mean that every
operation will disturb at most $diam(G)\cdot polylog(n)$ nodes of the network.

We also want our bank to be somewhat decentralized. We don't have a formal
definition for that, but generally it means that we don't want it to be managed
by a selected few nodes. We want it to be resilient to large amounts of
misbehaving nodes.

## Routing and Distributed Banking

In mesh networks there is a special relation between the problem of message
Routing and Distributed Banking.

Recall that at this document we seek a solution for Distributed Banking in
order to make our message routing algorithm fair. If user $x$ makes a heavier
use of the network than user $y$, then $x$ should pay more than user $y$.

It is interesting to observe the opposite direction of this relation: **If all
that we have is a solution for Distributed Banking, we can use it to implement
efficient routing.**

We roughly describe here this idea:
Assume that we have a mesh network with Distributed Banking, and let $x$ and
$y$ be two nodes. Also assume that $v_x \geq 2$. We want to efficiently route a
message from $x$ to $y$. For the sake of simplicity, assume that we want to
route a single bit $b \in \{0,1\}$ from $x$ to $y$.

First, $y$ performs Inquiry operation, to obtain his current balance. Next, $x$
will transfer to $y$'s $b+1$ money. $y$ will perform another Inquiry. If his
balance has increased by $1$, it means that $x$ has sent the bit $0$. If his
balance has increased by $2$, it means that $x$ has sent the bit $1$.

We assumed that all the operations in the distributed bank are efficient.
Therefore the bit was sent from $x$ to $y$ efficiently.

(TODO: Maybe remove first attempts, or just talk about bitcoin shortly later)


## About using the Bitcoin network

What about using the [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) network
as a distributed bank for our mesh network?

In the Bitcoin network, or in similar networks, every money transfer between
two nodes must be broadcasted to all the nodes in the network. In other words,
the Bitcoin network does not allow to perform efficient money transfer.

Recall that our original motivation to implement a distributed bank is to be
able to route messages in a fair and efficient manner along the network. If our
distributed bank does not allow efficient money transfer, we can not rely on it
to implement efficient routing.

## Initial Attempts

Consider a world of $n$ people. How could we create an economy in this world,
where every person can pay another person, and payments have some meaningful
value?

A common method to acheive such an economy would be to use cash: Bills and
coins. Those are artifacts that are hard to produce. A limited amount of bills
are printed, and people can exchange those bills as payment.

In the digital world of computers, we don't have an exact equivalent for cash.
This happens because digital objects can be duplicated easily. This problem is
sometimes referred to as [Double
Spending](https://en.wikipedia.org/wiki/Double-spending):
Assume that a user $x$ owns a digital bill. He could duplicate the digital bill
and pay the same bill simultaneously both to $y$ and $z$.


Instead of using Cash, we could use some concept of a bank instead. A balance
will be kept for every person. People can pay each other by updating their
balances accordingly (Increasing the destination balance, and decreasing the
source balance).

Now we have the problem of where and how to keep the balances.

A naive solution would be to let every person $x$ keep his own balance value,
$v_x$. This solution is also distributed: Every person has to remember just one
value. A transaction between people $x$ and $y$ only involves $x$ and $y$. If
$x$ wants to transfer $k$ money to $y$, $x$ decreases his own balance by $k$,
and $y$ increases his own balance by $k$.

The problem with this model is obvious: What if $x$ becomes greedy, and decides
to increase his own balance? Our economic system will be compromised.

At this point we understand that we can not trust all people to be honest.
Another solution would be to let just one special person $z$, to keep the
balances for all the nodes in the network.

Whenever $x$ wants to send $k$ money to $y$, $x$ will file a request
to $z$, saying that he wants to send $k$ money to node $y$.

$z$ will inspect $x$'s balance and make sure that $x$ has at least $k$ money.
If this is the case, $z$ will subtract $k$ from $x$'s balance, and add $k$ to
$y$'s balance.

(TODO: Add picture of a transaction done by $z$)

This solution is somewhat equivalent to the usual centralized bank. (The banks
that we have in the real world).

The weak point of the centralized bank is with $z$: The person that manages the
bank. He has full control over all the balances of all the participants.

In addition, every money transfer between two people $x$ and $y$ must go
through $z$. Therefore the economy can be only as efficient as the ability of
$z$ to process transactions.


## Introducing the trusted subset

> So the Lord scattered them abroad from there over the face of all the earth,
> and they ceased building the city. (Genesis 11:8)

Let $S$ be set of $n$ people. We have noticed that if we want to create an
economy between those people, we have to take into account the fact that some
people might try to cheat, given the opportunity.

To be able to talk formally, we need to have some model of when people might
cheat. We choose the following model: Every person in $S$ is either **Good** or
**Bad**. A good person always goes by the rules. All the Bad people collude
together to try to subvert the system.

We are going to assume that there are more good people than bad people in $S$.
There is some philosophy behind this assumption and we won't get to it now. For
now, think about it as giving the good people some kind of advantage. All
other things equal, it is hard to believe that a minority of good people in $S$
will be able to hold together a secure distributed bank. 

On the opposite side of things, it is reasonable to believe that a set with a
majority of good people is able to make correct decisions somehow with respect
to banking operations: Maybe through some kind of a smart voting system.

Let $x$ be some person in the network. We want to keep $x$'s balance on the
network, somehow. We have already noted that keeping this balance with just one
person is too centralized and fragile. On the other end of the spectrum,
making all the people in $S$ remember $x$'s balance at all times is very
resilient, but too inefficient. As a middle ground, we will choose a small
subset of people and let them remember $x$'s balance.

To make sure the members of the small subset do not collude to do something
bad, we pick the small set randomly.

Let $T \subseteq S$ a random subset of $S$. As there are more good people than
bad people in $S$, we expect that $T$ will also contain more good people than
bad people. 

Let's put in some numbers. Assume that the total amount of people is
$n=2^{r}$, and that the amount of bad people is $\alpha$ of all the people.
Next, we choose random sets $T$ of size $\log{n} = r$. What is the probability
$p_r$ that the amount of bad people in $T$ is more than $\beta$ of $T$?

$n$ is very large with respect to $|T|$, so for the ease of computation we will
assume that our population is infinite (And every person is bad with
probability of $\alpha$). This will give us a slightly wrong result, but not
too wrong. Now that the draw of a person from the pool of infinite person is
independent of other draws, we can use the [Multiplicative form of
Chernoff bound](https://en.wikipedia.org/wiki/Chernoff_bound) to
estimate $p_r$.

$$ Pr[X > (1+\delta)\miu] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

In our case $\miu = r\cdot\alpha$, which is the expected amount of bad people
in $T$. We pick $\delta = \frac{\beta - \alpha}{\alpha}$ to get:

$$ p_r \approx Pr[X > {\beta}\cdot r] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

If one out of 9 people is bad ($\alpha = 1/9$), the probability of having a
random subset $T$ of size $r=256$ with more than $\beta=1/3$ bad people is
(Calculation done with python):

    In : math.log2(prob_bad.calc_bad_prob(256,1/9,1/3))
    Out: -53.176815513188735

We got a probability of at most $2^{-53}$. This is a very unlikely event. So
with huge probability such a random set $T$ has less than $1/3$ fraction of bad
people.

(TODO: Write about the python code of prob_bad)


The above choice of the number $1/3$ was not arbitrary. There is a family of
algorithms called **Asynchronous Byzantine Agreement**. (We will call it ABA in
this document). An ABA algorithm can turn a set of $M$ of people with less than
$1/3$ bad people into one "virtual good person".

How does it work? An ABA algorithm is some kind of a smart vote between the
memebers of the set. It allows the set of people to make correct decisions with
very high probability, despite the existence of a minority of bad people in the
set.  (We will give the details of ABA in this document, but you can learn
about it from Ran Caneti's Thesis: Studies in Secure Multiparty Computation and
Applications, chapter 4.)

You might be wondering: Why didn't we use ABA from the first place, on the
whole set $S$? The reason is efficiency: Making all the people in $S$ vote over
every money transfer operation is too inefficient. Instead, we pick small
subsets of size about $\log(n)$, and run the ABA algorithm on them.

As a result we get "trusted subsets" of $S$.


## Basic banking operations

Now that we have the concept of trusted subsets, we can use it to store money
balances and perform money transfers. We describe here the general idea behind
the basic banking operations.

For every person $x$, we match a random subset $T_x \subseteq S$. The members
of $T_x$ will always keep the current balance of $x$.
Note that it is possible for two different people, $x$ and $y$, to have
intersecting random subsets. In other words, it is possible that $T_x \cap T_y
\neq \emptyset$

**Inquiry:** $x$ can perform an Inquiry operation by sending a request to the
members of $T_x$. The members of $T_x$ work together as one virtual good
person, using the ABA algorithm. Hence they will send back to $x$ his current
balance.

**Money Transfer:** If $x$ wants to send $k$ money to another person, $y$, $x$
can send a request to $T_x$ to transfer $k$ money to $y$. The members of $T_x$
will work together as one virtual good person: First they will check that the
current balance of $x$ is at least $k$. Then $T_x$ will decrease the balance of
$x$ by $k$. Next, $T_x$ will send a request to $T_y$ to increase the balance of
$y$ by $k$. The members of $T_y$ *should be able* to trust $T_x$, because $T_x$
is a randomly chosen subset of $S$, and it acts like a virtual good person.
Finally the members of $T_y$ will add $k$ to the balance of $y$.

The introduction of trusted subsets of $S$ creates a world of virtual
participans, where all the participants are good. This setting allows some new
possiblities that we will talk about in the future.






