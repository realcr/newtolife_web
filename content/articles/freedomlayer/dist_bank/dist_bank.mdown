Title: The Trusted Supernode and Distributed Banking
Date: 2015-12-08 12:43
Author: real


## Motivation

Assume a [mesh network](https://en.wikipedia.org/wiki/Mesh_networking) of
computers (nodes), working together to somehow navigate messages efficiently
across the network.

Life is all good, until at some point one computer (Let's call him $x$) starts
sending a lot of messages. He sends so many messages, that other computers have
problem sending and receiving messages. $x$'s use of the network makes it hard
for other users to use the network correctly.

$x$ is Bob's computer. Bob is a cool guy, but is also a pretty heavy network
user. He transfers large video files, and he also has a digital business that
relies on the networking services of the network.

If this was the normal Internet, at this point Bob will get a call from his
[ISP](https://en.wikipedia.org/wiki/Internet_service_provider) representative,
telling him either to stop what he is doing with the internet, or maybe upgrade
his internet package to a business class client.

But Bob's computer, $x$, is part of a mesh network. Mesh networks are not
managed by any central authority, hence there is no ISP to supervise Bob's
network usage.

It would be nice if the network itself could somehow supervise the network
usage of all the computers. If any computer uses too much bandwidth, he will
have to **pay something of value** to the other computers in the network. This
way, every user of the network could use the network as much as he wants, and
pay according to his use.

If we want to use payments in our network, we need to maintain some kind of a
bank: A distributed bank over the mesh network. In this document we discuss an
idea for creating such a bank.


## Requirements for Distributed Banking

Let's be more specific about what we want to acheive with our bank. For every
user $x$, a balance value $v_x$ is stored. $v_x$ is the amount of money that
$x$ owns.

Our bank should be able to perform the following operations **efficiently**:

1. Money Transfer: A user $x$ can send user $y$ amount money $u$ if $u \leq
   v_x$. After the money transfer, $x$'s balance value will be decreased by
   $u$, and $y$'s balance value will increase by $u$.

2. Inquiry: A user $x$ can get his current balance $v_x$.

Assume that there are $n$ nodes on the mesh network. Also assume that the
longest path between two nodes in the network is diam(G). (The
[diameter](https://en.wikipedia.org/wiki/Distance_%28graph_theory%29) of the
network G). Whenever we write "efficiently" in this document, we mean that every
operation will disturb at most $diam(G)\cdot polylog(n)$ nodes of the network.

We also want our bank to be somewhat decentralized. We don't have a formal
definition for that, but generally it means that we don't want it to be managed
by a selected few nodes. We want it to be resilient to large amounts of
misbehaving nodes.

## Routing and Distributed Banking

In mesh networks there is a special relation between the problem of message
Routing and Distributed Banking.

Recall that at this document we seek a solution for Distributed Banking in
order to make our message routing algorithm fair. If user $x$ makes a heavier
use of the network than user $y$, then $x$ should pay more than user $y$.

It is interesting to observe the opposite direction of this relation: **If all
that we have is a solution for Distributed Banking, we can use it to implement
efficient routing.**

We roughly describe here this idea:
Assume that we have a mesh network with Distributed Banking, and let $x$ and
$y$ be two nodes. Also assume that $v_x \geq 2$. We want to efficiently route a
message from $x$ to $y$. For the sake of simplicity, assume that we want to
route a single bit $b \in \{0,1\}$ from $x$ to $y$.

First, $y$ performs Inquiry operation, to obtain his current balance. Next, $x$
will transfer to $y$'s $b+1$ money. $y$ will perform another Inquiry. If his
balance has increased by $1$, it means that $x$ has sent the bit $0$. If his
balance has increased by $2$, it means that $x$ has sent the bit $1$.

We assumed that all the operations in the distributed bank are efficient.
Therefore the bit was sent from $x$ to $y$ efficiently.

(TODO: Maybe remove first attempts, or just talk about bitcoin shortly later)


## About using the Bitcoin network

What about using the [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) network
as a distributed bank for our mesh network?

In the Bitcoin network, or in similar networks, every money transfer between
two nodes must be broadcasted to all the nodes in the network. In other words,
the Bitcoin network does not allow to perform efficient money transfer.

Recall that our original motivation to implement a distributed bank is to be
able to route messages in a fair and efficient manner along the network. If our
distributed bank does not allow efficient money transfer, we can not rely on it
to implement efficient routing.

## Initial Attempts

Consider a world of $n$ people. How could we create an economy in this world,
where every person can pay another person, and payments have some meaningful
value?

A common method to acheive such an economy would be to use cash: Bills and
coins. Those are artifacts that are hard to produce. A limited amount of bills
are printed, and people can exchange those bills as payment.

In the digital world of computers, we don't have an exact equivalent for cash.
This happens because digital objects can be duplicated easily. This problem is
sometimes referred to as [Double
Spending](https://en.wikipedia.org/wiki/Double-spending):
Assume that a user $x$ owns a digital bill. He could duplicate the digital bill
and pay the same bill simultaneously both to $y$ and $z$.


Instead of using Cash, we could use some concept of a bank instead. A balance
will be kept for every person. People can pay each other by updating their
balances accordingly (Increasing the destination balance, and decreasing the
source balance).

Now we have the problem of where and how to keep the balances.

A naive solution would be to let every person $x$ keep his own balance value,
$v_x$. This solution is also distributed: Every person has to remember just one
value. A transaction between people $x$ and $y$ only involves $x$ and $y$. If
$x$ wants to transfer $k$ money to $y$, $x$ decreases his own balance by $k$,
and $y$ increases his own balance by $k$.

The problem with this model is obvious: What if $x$ becomes greedy, and decides
to increase his own balance? Our economic system will be compromised.

At this point we understand that we can not trust all people to be honest.
Another solution would be to let just one special person $z$, to keep the
balances for all the nodes in the network.

Whenever $x$ wants to send $k$ money to $y$, $x$ will file a request
to $z$, saying that he wants to send $k$ money to node $y$.

$z$ will inspect $x$'s balance and make sure that $x$ has at least $k$ money.
If this is the case, $z$ will subtract $k$ from $x$'s balance, and add $k$ to
$y$'s balance.

(TODO: Add picture of a transaction done by $z$)

This solution is somewhat equivalent to the usual centralized bank. (The banks
that we have in the real world).

The weak point of the centralized bank is with $z$: The person that manages the
bank. He has full control over all the balances of all the participants.

In addition, every money transfer between two people $x$ and $y$ must go
through $z$. Therefore the economy can be only as efficient as the ability of
$z$ to process transactions.


## A Trusted group

Let $S$ be set of $n$ people. We have noticed that if we want to create an
economy between those people, we have to take into account the fact that some
people might try to cheat, given the opportunity.

To be able to talk formally, we need to have some model of when people might
cheat. We choose the following model: Every person in $S$ is either **Good** or
**Bad**. A good person always goes by the rules. All the Bad people collude
together to try to subvert the system.

We are going to assume that there are more good people than bad people in $S$.
There is some philosophy behind this assumption: If we ever manage to have a
distributed bank on a setting where there are more bad people than good people,
it means that this distributed bank is controlled by a minority, and hence it
is not really distributed.


Let $T \subseteq S$ a random subset of $S$. As there are more good people than
bad people in $S$, we expect that $T$ will also contain more good people than
bad people. 

Let's put in some numbers. Assume that the total amount of people is
$n=2^{r}$, and that the amount of bad people is $\alpha$ of all the people.
Next, we choose random sets $T$ of size $\log{n} = r$. What is the probability
$p_r$ that the amount of bad people in $T$ is more than $\beta$ of $T$?

$n$ is very large with respect to $|T|$, so for the ease of computation we will
assume that our population is infinite (And every person is bad with
probability of $\alpha$). This will give us a slightly wrong result, but not
too wrong. Now that the draw of a person from the pool of infinite person is
independent of other draws, we can use the [Multiplicative form of
Chernoff bound](https://en.wikipedia.org/wiki/Chernoff_bound) to
estimate $p_r$.

$$ Pr[X > (1+\delta)\miu] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

In our case $\miu = r\cdot\alpha$, which is the expected amount of bad people
in $T$. We pick $\delta = \frac{\beta - \alpha}{\alpha}$ to get:

$$ Pr[X > {\beta}\cdot r] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

If one out of 9 people is bad ($\alpha = 1/9$), the probability of having a
random subset $T$ of size $r=256$ with more than $\beta=1/3$ bad people is
(Calculation done with python):

    In : math.log2(prob_bad.calc_bad_prob(256,1/9,1/3))
    Out: -53.176815513188735

About $2^{-53}$. This is a very unlikely event.

(TODO: Write about the python code of prob_bad)


Generally it will be a bad idea to trust a random person from $S$,
but it could be a good idea to trust a large enough random set $T$. We could,
for example, ask the members of a random set $T_x$ to keep the balance value of
some person $x$.


