Title: The Trusted Supernode and Distributed Banking
Date: 2015-12-08 12:43
Author: real


## Motivation

Assume a [mesh network](https://en.wikipedia.org/wiki/Mesh_networking) of
computers (nodes), working together to somehow navigate messages efficiently
across the network.

Life is all good, until at some point one computer (Let's call him $x$) starts
sending a lot of messages. He sends so many messages, that other computers have
problem sending and receiving messages. $x$'s use of the network makes it hard
for other users to use the network correctly.

$x$ is Bob's computer. Bob is a cool guy, but is also a pretty heavy network
user. He transfers large video files, and he also has a digital business that
relies on the networking services of the network.

If this was the normal Internet, at this point Bob will get a call from his
[ISP](https://en.wikipedia.org/wiki/Internet_service_provider) representative,
telling him either to stop what he is doing with the internet, or maybe upgrade
his internet package to a business class client.

But Bob's computer, $x$, is part of a mesh network. Mesh networks are not
managed by any central authority, hence there is no ISP to supervise Bob's
network usage.

It would be nice if the network itself could somehow supervise the network
usage of all the computers. If any computer uses too much bandwidth, he will
have to **pay something of value** to the other computers in the network. This
way, every user of the network could use the network as much as he wants, and
pay according to his use.

If we want to use payments in our network, we need to maintain some kind of a
bank: A distributed bank over the mesh network. In this document we discuss an
idea for creating such a bank.


## Requirements for Distributed Banking

Let's be more specific about what we want to acheive with our bank. For every
user $x$, a balance value $v_x$ is stored. $v_x$ is the amount of money that
$x$ owns.

Our bank should be able to perform the following operations **efficiently**:

1. Money Transfer: A user $x$ can send user $y$ amount money $u$ if $u \leq
   v_x$. After the money transfer, $x$'s balance value will be decreased by
   $u$, and $y$'s balance value will increase by $u$.

2. Inquiry: A user $x$ can get his current balance $v_x$.

Assume that there are $N$ nodes on the mesh network. Also assume that the
longest path between two nodes in the network is diam(G). (The
[diameter](https://en.wikipedia.org/wiki/Distance_%28graph_theory%29) of the
network G). Whenever we write "efficiently" in this document, we mean that every
operation will disturb at most $diam(G)\cdot polylog(N)$ nodes of the network.

We also want our bank to be somewhat decentralized. We don't have a formal
definition for that, but generally it means that we don't want it to be managed
by a selected few nodes. We want it to be resilient to large amounts of
misbehaving nodes.

## Routing and Distributed Banking

In mesh networks there is a special relation between the problem of message
Routing and Distributed Banking.

Recall that at this document we seek a solution for Distributed Banking in
order to make our message routing algorithm fair. If user $x$ makes a heavier
use of the network than user $y$, then $x$ should pay more than user $y$.

It is interesting to observe the opposite direction of this relation: **If all
that we have is a solution for Distributed Banking, we can use it to implement
efficient routing.**

We roughly describe here this idea:
Assume that we have a mesh network with Distributed Banking, and let $x$ and
$y$ be two nodes. Also assume that $v_x \geq 2$. We want to efficiently route a
message from $x$ to $y$. For the sake of simplicity, assume that we want to
route a single bit $b \in \{0,1\}$ from $x$ to $y$.

First, $y$ performs Inquiry operation, to obtain his current balance. Next, $x$
will transfer to $y$'s $b+1$ money. $y$ will perform another Inquiry. If his
balance has increased by $1$, it means that $x$ has sent the bit $0$. If his
balance has increased by $2$, it means that $x$ has sent the bit $1$.

We assumed that all the operations in the distributed bank are efficient.
Therefore the bit was sent from $x$ to $y$ efficiently.

(TODO: Maybe remove first attempts, or just talk about bitcoin shortly later)

## First attempts

We mention here some first attempts to implement a bank over the mesh.

**1. Centralized bank.** 
Let one node $z$ keep the balances of all the nodes in
the network. Every node in the mesh maintains a shortest path to the node $z$.
Inquiry and Transfer operations are performed by sending a request to $z$.

All the bank operations are done efficiently: A request sent from a node $x$ to
the node $z$ passes through at most $diam(G)$.

The problem with this idea for a bank is that the proposed bank is centralized:

- The node $z$ has full control over the balances of all the nodes in the
  network. If $z$ ever gets too greedy (And most likely he will), the bank and
  the network will be compromised.

- The node $z$ has to deal with requests from all the nodes in the network,
  which is probably too much for one node.


**2. Implementing a blockchain network.**
Make sure to 
The [bitcoin](https://en.wikipedia.org/wiki/Bitcoin) network is a distributed
bank system. It operates by maintaining a consensus over an ordered list
([Blockchain](https://en.wikipedia.org/wiki/Block_chain_%28database%29)) of all
the transactions that ever took place between the participants.

A blockchain network is decentralized: All the participants keep the full
history of all the transactions, and hence all the participants know the
current balance of all the other participants.

However, a blockchain network does not allow to perform the Transfer operation
efficiently. If a node $x$ wants to transfer money to node $y$, he has to send
a message that passes through all the nodes in the network.

Recall that our main reason for designing a distributed bank system is to allow
efficient and fair routing of messages. If our bank does not allow money
transfer efficiently, we can not rely on it to route message efficiently.


## Thoughts about distributed banking

Consider a world of $N$ people. How could we create an economy in this world,
where every person can pay another person, and payments have some meaningful
value?

A common method to acheive such an economy would be to use cash: Bills and
coins. Those are artifacts that are hard to produce. A limited amount of bills
are printed, and people can exchange those bills as payment.

In the digital world of computers, we don't have an exact equivalent for cash.
This happens because digital objects can be duplicated easily. This problem is
sometimes referred to as [Double
Spending](https://en.wikipedia.org/wiki/Double-spending):
Assume that a user $x$ owns a digital bill. He could duplicate the digital bill
and pay the same bill simultaneously both to $y$ and $z$.


Instead of using Cash, we could use some concept of a bank instead. A balance
will be kept for every person. People can pay each other by updating their
balances accordingly (Increasing the destination balance, and decreasing the
source balance).

Now we have the problem of where and how to keep the balances.

A naive solution would be to let every person $x$ keep his own balance value,
$v_x$. This solution is also distributed: Every person has to remember just one
value. A transaction between people $x$ and $y$ only involves $x$ and $y$. If
$x$ wants to transfer $k$ money to $y$, $x$ decreases his own balance by $k$,
and $y$ increases his own balance by $k$.

The problem with this model is obvious: What if $x$ becomes greedy, and decides
to increase his own balance? Our economic system will be compromised.

At this point we understand that we can not trust all people to be honest.
Another solution would be to let just one special person $z$, to keep the
balances for all the nodes in the network.

Whenever $x$ wants to send $k$ money to $y$, $x$ will file a request
to $z$, saying that he wants to send $k$ money to node $y$.

$z$ will inspect $x$'s balance and make sure that $x$ has at least $k$ money.
If this is the case, $z$ will subtract $k$ from $x$'s balance, and add $k$ to
$y$'s balance.






