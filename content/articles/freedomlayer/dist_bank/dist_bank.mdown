Title: The Trusted Supernode and Distributed Banking
Date: 2015-12-08 12:43
Author: real


## Motivation

Assume a [mesh network](https://en.wikipedia.org/wiki/Mesh_networking) of
computers (nodes), working together to somehow navigate messages efficiently
across the network.

Life is all good, until at some point one computer (Let's call him $x$) starts
sending a lot of messages. He sends so many messages, that other computers have
problem sending and receiving messages. $x$'s use of the network makes it hard
for other users to use the network correctly.

$x$ is Bob's computer. Bob is a cool guy, but is also a pretty heavy network
user. He transfers large video files, and he also has a digital business that
relies on the networking services of the network.

If this was the normal Internet, at this point Bob will get a call from his
[ISP](https://en.wikipedia.org/wiki/Internet_service_provider) representative,
telling him either to stop what he is doing with the internet, or maybe upgrade
his internet package to a business class client.

But Bob's computer, $x$, is part of a mesh network. Mesh networks are not
managed by any central authority, hence there is no ISP to supervise Bob's
network usage.

It would be nice if the network itself could somehow supervise the network
usage of all the computers. If any computer uses too much bandwidth, he will
have to **pay something of value** to the other computers in the network. This
way, every user of the network could use the network as much as he wants, and
pay according to his use.

If we want to use payments in our network, we need to maintain some kind of a
bank: A distributed bank over the mesh network. In this document we discuss an
idea for creating such a bank.


## Requirements for Distributed Banking

Let's be more specific about what we want to acheive with our bank. For every
user $x$, a balance value $v_x$ is stored. $v_x$ is the amount of money that
$x$ owns.

Our bank should be able to perform the following operations **efficiently**:

1. Money Transfer: A user $x$ can send user $y$ amount money $u$ if $u \leq
   v_x$. After the money transfer, $x$'s balance value will be decreased by
   $u$, and $y$'s balance value will increase by $u$.

2. Inquiry: A user $x$ can get his current balance $v_x$.

Assume that there are $n$ nodes on the mesh network. Also assume that the
longest path between two nodes in the network is diam(G). (The
[diameter](https://en.wikipedia.org/wiki/Distance_%28graph_theory%29) of the
network G). Whenever we write "efficiently" in this document, we mean that every
operation will disturb at most $diam(G)\cdot polylog(n)$ nodes of the network.

We also want our bank to be somewhat decentralized. We don't have a formal
definition for that, but generally it means that we don't want it to be managed
by a selected few nodes. We want it to be resilient to large amounts of
misbehaving nodes.

## Routing and Distributed Banking

In mesh networks there is a special relation between the problem of message
Routing and Distributed Banking.

Recall that at this document we seek a solution for Distributed Banking in
order to make our message routing algorithm fair. If user $x$ makes a heavier
use of the network than user $y$, then $x$ should pay more than user $y$.

It is interesting to observe the opposite direction of this relation: **If all
that we have is a solution for Distributed Banking, we can use it to implement
efficient routing.**

We roughly describe here this idea:
Assume that we have a mesh network with Distributed Banking, and let $x$ and
$y$ be two nodes. Also assume that $v_x \geq 2$. We want to efficiently route a
message from $x$ to $y$. For the sake of simplicity, assume that we want to
route a single bit $b \in \{0,1\}$ from $x$ to $y$.

First, $y$ performs Inquiry operation, to obtain his current balance. Next, $x$
will transfer to $y$'s $b+1$ money. $y$ will perform another Inquiry. If his
balance has increased by $1$, it means that $x$ has sent the bit $0$. If his
balance has increased by $2$, it means that $x$ has sent the bit $1$.

We assumed that all the operations in the distributed bank are efficient.
Therefore the bit was sent from $x$ to $y$ efficiently.

(TODO: Maybe remove first attempts, or just talk about bitcoin shortly later)


## About using the Bitcoin network

What about using the [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) network
as a distributed bank for our mesh network?

In the Bitcoin network every money transfer between two nodes must be
broadcasted to all the nodes in the network. In other words, the Bitcoin
network does not allow to perform efficient money transfer.

Recall that our original motivation to implement a distributed bank is to be
able to route messages in a fair and efficient manner along the network. If our
distributed bank does not allow efficient money transfer, we can not rely on it
to implement efficient routing.


## Initial Attempts

Consider a world of $n$ people. How could we create an economy in this world,
where every person can pay another person, and payments have some meaningful
value?

A common method to acheive such an economy would be to use cash: Bills and
coins. Those are artifacts that are hard to produce. A limited amount of bills
are printed, and people can exchange those bills as payment.

In the digital world of computers, we don't have an exact equivalent for cash.
This happens because digital objects can be duplicated easily. This problem is
sometimes referred to as [Double
Spending](https://en.wikipedia.org/wiki/Double-spending):
Assume that a user $x$ owns a digital bill. He could duplicate the digital bill
and pay the same bill simultaneously both to $y$ and $z$.


Instead of using Cash, we could use some concept of a bank instead. A balance
will be kept for every person. People can pay each other by updating their
balances accordingly (Increasing the destination balance, and decreasing the
source balance).

Now we have the problem of where and how to keep the balances.

A naive solution would be to let every person $x$ keep his own balance value,
$v_x$. This solution is also distributed: Every person has to remember just one
value. A transaction between people $x$ and $y$ only involves $x$ and $y$. If
$x$ wants to transfer $k$ money to $y$, $x$ decreases his own balance by $k$,
and $y$ increases his own balance by $k$.

The problem with this model is obvious: What if $x$ becomes greedy, and decides
to increase his own balance? Our economic system will be compromised.

At this point we understand that we can not trust all people to be honest.
Another solution would be to let just one special person $z$, to keep the
balances for all the nodes in the network.

Whenever $x$ wants to send $k$ money to $y$, $x$ will file a request
to $z$, saying that he wants to send $k$ money to node $y$.

$z$ will inspect $x$'s balance and make sure that $x$ has at least $k$ money.
If this is the case, $z$ will subtract $k$ from $x$'s balance, and add $k$ to
$y$'s balance.

(TODO: Add picture of a transaction done by $z$)

This solution is somewhat equivalent to the usual centralized bank. (The banks
that we have in the real world).

The weak point of the centralized bank is with $z$: The person that manages the
bank. He has full control over all the balances of all the participants.

In addition, every money transfer between two people $x$ and $y$ must go
through $z$. Therefore the economy can be only as efficient as the ability of
$z$ to process transactions.


## Introducing the trusted subset

> So the Lord scattered them abroad from there over the face of all the earth,
> and they ceased building the city. (Genesis 11:8)

Let $S$ be set of $n$ people. We have noticed that if we want to create an
economy between those people, we have to take into account the fact that some
people might try to cheat, given the opportunity.

To be able to talk formally, we need to have some model of when people might
cheat. We choose the following model: Every person in $S$ is either **Good** or
**Bad**. A good person always goes by the rules. All the Bad people collude
together to try to subvert the system.

We are going to assume that there are more good people than bad people in $S$.
There is some philosophy behind this assumption and we won't get to it now. For
now, think about it as giving the good people some kind of advantage. All
other things equal, it is hard to believe that a minority of good people in $S$
will be able to hold together a secure distributed bank. 

On the opposite side of things, it is reasonable to believe that a set with a
majority of good people is able to make correct decisions somehow with respect
to banking operations: Maybe through some kind of a smart voting system.

Let $x$ be some person in the network. We want to keep $x$'s balance on the
network, somehow. We have already noted that keeping this balance with just one
person is too centralized and fragile. On the other end of the spectrum,
making all the people in $S$ remember $x$'s balance at all times is very
resilient, but too inefficient. As a middle ground, we will choose a small
subset of people and let them remember $x$'s balance.

To make sure the members of the small subset do not collude to do something
bad, we pick the small set randomly.

Let $T \subseteq S$ a random subset of $S$. As there are more good people than
bad people in $S$, we expect that $T$ will also contain more good people than
bad people. 

Let's put in some numbers. Assume that the total amount of people is
$n=2^{r}$, and that the amount of bad people is $\alpha$ of all the people.
Next, we choose random sets $T$ of size $\log{n} = r$. What is the probability
$p_r$ that the amount of bad people in $T$ is more than $\beta$ of $T$?

$n$ is very large with respect to $|T|$, so for the ease of computation we will
assume that our population is infinite (And every person is bad with
probability of $\alpha$). This will give us a slightly wrong result, but not
too wrong. Now that the draw of a person from the pool of infinite person is
independent of other draws, we can use the [Multiplicative form of
Chernoff bound](https://en.wikipedia.org/wiki/Chernoff_bound) to
estimate $p_r$.

$$ Pr[X > (1+\delta)\miu] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

In our case $\miu = r\cdot\alpha$, which is the expected amount of bad people
in $T$. We pick $\delta = \frac{\beta - \alpha}{\alpha}$ to get:

$$ p_r \approx Pr[X > {\beta}\cdot r] < {\left(\frac{e^{\delta}}{(1+\delta)^{(1 +
\delta)}}\right)}^\miu $$

If one out of 9 people is bad ($\alpha = 1/9$), the probability of having a
random subset $T$ of size $r=256$ with more than $\beta=1/3$ bad people is
(Calculation done with python):

    In : math.log2(prob_bad.calc_bad_prob(256,1/9,1/3))
    Out: -53.176815513188735

We got a probability of at most $2^{-53}$. This is a very unlikely event. So
with huge probability such a random set $T$ has less than $1/3$ fraction of bad
people.

(TODO: Write about the python code of prob_bad)


The above choice of the number $1/3$ was not arbitrary. There is a family of
algorithms called **Asynchronous Byzantine Agreement**. (We will call it ABA in
this document). An ABA algorithm can turn a set of $M$ of people with less than
$1/3$ bad people into one "virtual good person".

How does it work? An ABA algorithm is some kind of a smart vote between the
memebers of the set. It allows the set of people to make correct decisions with
very high probability, despite the existence of a minority of bad people in the
set.  (We will give the details of ABA in this document, but you can learn
about it from Ran Caneti's Thesis: Studies in Secure Multiparty Computation and
Applications, chapter 4.)

You might be wondering: Why didn't we use ABA from the first place, on the
whole set $S$? The reason is efficiency: Making all the people in $S$ vote over
every money transfer operation is too inefficient. Instead, we pick small
subsets of size about $\log(n)$, and run the ABA algorithm on them.

As a result we get "trusted subsets" of $S$.


## Basic banking operations

Now that we have the concept of trusted subsets, we can use it to store money
balances and perform money transfers. We describe here the general idea behind
the basic banking operations.

For every person $x$, we match a random subset $T_x \subseteq S$. The members
of $T_x$ will always keep the current balance of $x$.
Note that it is possible for two different people, $x$ and $y$, to have
intersecting random subsets. In other words, it is possible that $T_x \cap T_y
\neq \emptyset$

**Inquiry:** $x$ can perform an Inquiry operation by sending a request to the
members of $T_x$. The members of $T_x$ work together as one virtual good
person, using the ABA algorithm. Hence they will send back to $x$ his current
balance.

**Money Transfer:** If $x$ wants to send $k$ money to another person, $y$, $x$
can send a request to $T_x$ to transfer $k$ money to $y$. The members of $T_x$
will work together as one virtual good person: First they will check that the
current balance of $x$ is at least $k$. Then $T_x$ will decrease the balance of
$x$ by $k$. Next, $T_x$ will send a request to $T_y$ to increase the balance of
$y$ by $k$. The members of $T_y$ *should be able* to trust $T_x$, because $T_x$
is a randomly chosen subset of $S$, and it acts like a virtual good person.
Finally the members of $T_y$ will add $k$ to the balance of $y$.

The introduction of trusted subsets of $S$ creates a world of virtual
participans, where all the participants are good. This setting allows some new
possiblities that we will talk about in the future.


## The lifetime of a Supernode

To make our discussion more exact, let's go back to talk about computers.
We are given a set of $S$ nodes that can somehow communicate efficiently, and
we want to implement a distributed bank. Every node $x$ is matched with a
random subset $T_x \subseteq S$ that keeps his balance.

We begin by addressing an important issue with respect to computers: They are
not always online.

Let $x$ be some node. Assume that some of the nodes in $T_x$ get offline, or
end their lifetime (It happens to computers too!). Over time it is possible
that no nodes from $T_x$ will be online. How can we make sure that $x$'s
balance will not be erased?

To solve this issue, $x$'s subset $T_x$ must be dynamic. It must be able to
change its members over time, with respect to changes in the network. We will
call the dynamic set of nodes that keep $x$'s balance $sup_x$, or: $x$'s
**Supernode**. This new name denotes the fact that $x$'s balance is kept by a
dynamic entity, not by a static set.

If some node dies, it should be somehow replaced by a new randomly selected
node. In addition, members of $sup_x$ should be removed randomly from time to
time, to keep the random structure of $sup_x$. (We don't want bad nodes to stay
forever in $sup_x$ while good nodes leave). The supernode has the
responsibility of keeping itself alive.

However, The dynamic nature of Supernodes poses some new trust questions.
Consider this example: Let $x$ and $y$ be two nodes, and assume that $x$ wants
to transfer $k$ money to $y$. $x$ contacts $sup_x$, which subtracts $k$ from
$x$'s balance, and then sends a request to $sup_y$ to add $k$ to $y$'s balance.

How can $sup_y$ know that it can trust $sup_x$? Maybe $sup_x$ is some
artificial set that was invented by $y$, because $y$ wants to increase his
balance? 

We break this question to smaller parts. 
Assume that a node $z$ once knew that a set $G$ of nodes is a supernode. After
a while while he encounters a differet set $G'$, which claims to be the same
supernode as the original set, $G$. How can $z$ verify that $G'$ is the same
supernode as the original $G$?

To "transfer the trust" from $G$ to $G'$, we can use [digital
signatures](https://en.wikipedia.org/wiki/Digital_signature). Assume that each
node can cryptographically sign a block of data. 

Let $G_1$ be the set of nodes of some supernode.
Assume that some node $z$ knows that the set of nodes $G_1$ is a supernode. 
Now assume that some node has joined $G$, or some node has left $G$. We mark
the new structure of the supernode to be $G_2$. Every node from $G_1$ signs the
new structure of the $G_2$. The set of all those signatures is a proof that the
supernode has changed its structure from $G_1$ to $G_2$.

The supernode keeps changing over time. $G_2$ changes to $G_3$ and so on.
Whenever it changes, a new set of signatures is added, as an evidence for the
structure change. The memebers of the supernode keep the chain of sets of
signatures at all times.

After a while, $z$ encounters a some set $G' = G_u$ of nodes. $G'$ can then
prove that it is the same supernode as the original $G_1$ by showing $z$ the
chain of all signatures, leading from the original structure $G_1$, all the way
to $G'$.

$z$ knows that the original set, $G_1$, was a supernode, therefore its members
were somehow sampled randomly from $S$. Hence in the set of signatures proving
the change from $G_1$ to $G_2$, there must be a signature of a good node. $z$
doesn't know which one of those signatures was signed by a good node, but he
knows that at least $2/3$ of those signatures were signed by good nodes.

A good node will not sign over fake structure changes. Therefore $z$ can be
sure that indeed the new set $G_2$ is also a supernode. If, for example, the
change was adding a new node, $z$ can be sure that this new node was sampled
randomly from $S$.

In the same way, $z$ can be sure that the change from $G_2$ to $G_3$ is valid,
and so on. Finally, given a valid chain of signature sets, $z$ can be sure that
$G'$ is the same supernode as the original one, $G_1$.


## The birth of a Supernode

The section about "lifetime of a supernode" explains how supernodes change over
time. However, it does not explain how they are initially created.

Assume that $x$ has some supernode $sup_x$. $y$ can ask $x$ to create a new
supernode for him. In that case, $x$ will send a request to $sup_x$ to create a
new supernode $sup_y$ for $y$.

The supernode $sup_x$ will then randomly select a subset of $S$, and call it
$sup_y$. It will also initialize some balance value for $y$. All the members of
$sup_x$ will sign over the structure of the newly created supernode, $sup_y$,
and hand those signatures to the members of $sup_y$, together with all the
signatures of the history of changes $sup_x$.

Let $z$ be some node. Assume that $z$ knew in the the past that some set $G$ is
the set of members of the supernode $sup_x$. If $z$ ever encounters a set of
nodes $P$ that claim to be the supernode $sup_y$, $z$ will be able to verify
this statement by verifying the chain of signature sets all the way from the
supernode structure $G$ to the creation of $sup_y$. 

$z$ will have to verify all the changes that happened to $sup_x$ since the
member set $G$, the creation of the supernode $sup_y$, and then all the changes
that happened to the supernode $sup_y$ until its current structure, $P$.

It is hard to create a new fake supernode, because the sigantures of members of
a real supernode are required, and a real supernode contains a majority of good
nodes, which will not be willing to sign.

We described here a way to create a new supernode, given that we have a
supernode already. We are going to assume that our network have some initial
supernode, and all the supernodes in the network will be his children, in some
sense.

Every supernode $sup$ will keep in memory a chain of set of signatures,
describing everything that happened until its creation. This chain is used as a
proof that $sup$ is a valid supernode.


You must be worried right now about the size of the chains that every supernode
has to remember, and you are correct: The chains keep growing as time goes by
and the supernodes change. Generally, every supernode should remember a chain
which is of size about $O(t)$, where $t$ is the time that has passed since the
beginning of the network. We will talk about a solution for this problem later.


## The death of a Supernode

Given that $x$ has created a some supernode $sup_x$, should this supernode stay
alive forever? 

Managing a Supernode is not a full time job for its members, but it does take
some resources. The supernode members have to respond to various requests to
the supernode, find new members or remove old members from time to time.

To make sure that supernodes are not created carelessly, it is possible to
deduct some money from the supernode owner on a timely basis.
The supernode $sup_x$ will decrease $x$'s balance by a small amount every few
minutes, for example. This is easy to implement, because the supernode $sup_x$
is the supernode who maintains the $x$'s money balance.

Using this method, the supernode will only keep living if $x$ has enough money
to "support" it. When $x$'s balance becomes $0$, the supernode will diassemble
and die.

Using this method we can also allow one node $x$ creating more than one
supernode. $x$ can use each supernode that he creates as a separate wallet, or
even, a separate instance of a virtual trusted computer.


## Shortening the proof chains

It could be nice if every supernode $sup$ will have to remember just a short
proof for his realness, instead of remembering a full chain of sets of
signatures, all the way to the first supernode ever created.



