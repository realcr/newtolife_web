Title: Multi Named VDHT Routing
Date: 2015-10-17 10:49
Author: real
status: draft

## Abstract

We are given a connected mesh network of $n$ nodes, where each node has a unique
name from the range of $[0,2^l)$. We assume that $n \leq 2^l$. Every node is
directly connected to a few other nodes.

We present an iterative distributed algorithm that allows each node $x$ to
maintain contact with a few key nodes. The connections with those key nodes
allows efficient routing of messages between any two nodes using greedy methods.

We prove that the presented iterative distributed algorithm always converges to
a good solution, given that the mesh network is connected.


## Previous attempts

In ["Experimenting with Virtual DHT
Routing"]({filename}/articles/freedomlayer/exp_virtual_dht_routing/exp_virtual_dht_routing.mdown)
we have presented an iterative distributed algorithm that allows each node $x$
to maintain contact with a few key nodes that are close to $x \pm 2^t$. We used
experiments to show that this algorithm can work in some cases, but we didn't
provide any rigorous proof for those claims.

In ["About cycles in stationary states of VDHT routing
algorithms"]({filename}/articles/freedomlayer/vdht_cycles_rounds/vdht_cycles_rounds.mdown)
we presented a slightly different iterative distributed algorithm, IterF, that
also allows each node $x$ to maintain contact to a few key nodes that are close
to $x \pm 2^t$. 

We have managed to prove that after IterF converges, we end up with possibly a
few disjoint sets of nodes (OneRound Theorem). In each such set $S$, for every
two nodes $a,b \in S$ it is possible to route messages efficiently between $a$
and $b$. However, we do not know how to efficiently route messages between nodes
from different disjoin sets.

We present here a modification to the IterF algorithm, called MIterF (Multi
named IterF), which is proven to converge to just one set of nodes $S$, such
that for every two nodes $a,b \in S$ it is possible to route messages
efficiently between $a$ and $b$.


## Nodes that must share a cycle

Recall that the IterF algorithm eventually converges to a stationary state. Also
recall that in a stationary state of the IterF algorithm the nodes are divided
to disjoint cycles (of one round each). Our analysis didn't show which node will
end up at which cycle.

We will now discuss a few cases of pairs of nodes who we know for sure will end
up on the same cycle at a stationary state of IterF.

**Lemma (SameCycleA):** If $x$ is connected directly to a node $y$ of the form
$y = \pm 2^k \pm 2^t$ where $0 \leq k,t < l$, then $x$ and $y$ must be on the
same cycle on any stationary state of the IterF algorithm.

(TODO: Add a picture that describes an example of SameCycleA)

**Proof:** For readability reasons we will only deal with the case of $y = x +
2^k + 2^t$. The other cases can be proved in the same way, but with inverted
plus and minus symbols.

Assume a stationary state of the IterF algorithm.
We first show that $\overleftarrow{(x + 2^k + 2^t)_{-2^k}} =
\overleftarrow{x_{2^t}}$. Suppose that $\overleftarrow{(x + 2^k + 2^t)_{-2^k}}
\neq \overleftarrow{x_{2^t}}$. 

(TODO: Add a picture of all the relevant nodes here).

Then we can distinct between two cases:

*Case 1:* $\overleftarrow{(x + 2^k + 2^t)_{-2^k}} \in
(\overleftarrow{x_{2^t}},x+2^t]$. In that case in the next iteration of the
algorithm $x$ will update $\overleftarrow{x_{2^t}}$ to be $\overleftarrow{(x +
2^k + 2^t)_{-2^k}}$, because it is closer to $x+2^t$ from the left (clockwise).
This is a contradiction to the stationary state of IterF.

*Case 2:* $\overleftarrow{(x + 2^k + 2^t)_{-2^k}} \in
(x+2^t,\overleftarrow{x_{2^t}})$. In that case in the next iteration of the
algorithm $y = x + 2^k + 2^t$ will update $\overleftarrow{y_{-2^k}}$ to be
$\overleftarrow{x_{2^t}}$, because it is closer to $x+2^t$ from the left
(clockwise). This is a contradiction to the stationary state of IterF.

Thus it must be true that $\overleftarrow{y_{-2^k}} = \overleftarrow{x_{2^t}}$.

By the Locality lemma (see ["About cycles in stationary states of VDHT routing
algorithms"]({filename}/articles/freedomlayer/vdht_cycles_rounds/vdht_cycles_rounds.mdown))
there is a direct path between $x$ and $\overleftarrow{x_{2^t}}$, and so $x$ and
$\overleftarrow{x_{2^t}}$ must be on the same cycle. In the same way, there is a
direct path between $\overleftarrow{y_{-2^k}}$ to $y$, therefore
$\overleftarrow{y_{-2^k}}$ and $y$ must be on the same cycle.

As $\overleftarrow{y_{-2^k}} = \overleftarrow{x_{2^t}}$, we conclude that $x$
and $y$ must be on the same cycle. **QED**


**Lemma (SameCycleB):** If $x$ is connected directly to a node $y$, which is
connected directly to a node $z$ of the form $z = x \pm 2^k$, where $0 \leq k <
l$, then $x$ and $z$ must be on the same cycle on any stationary state of the
ITerF algorithm.

(TODO: Add a picture that describes an example of SameCycleB)

**Proof:**
For readability reasons we will only deal with the case of $z = x + 2^k$. The
other case could be proved in a similar way.

Assume a stationary state of the IterF algorithm. We first show that
$\overleftarrow{x_{2^k}} =
x + 2^k$. Suppose that $\overleftarrow{x_{2^k}} \neq x + 2^k$. Then in the next
iteration $y$ will tell $x$ about $z = x + 2^k$, and $x$ will update
$\overleftarrow{x_{2^k}}$ to be $x+2^k$, because it is closer to $x+2^k$ from
the left (It has distance 0!). This is a contradiction to the stationary state
of IterF. Therefore we conclude that $\overleftarrow{x_{2^k}} = x + 2^k = z$.

By the Locality lemma there is a direct path between $x$ and
$\overleftarrow{x_{2^k}} = z$. Therefore there is a direct path between $x$ and
$z$, and so $x$ and $z$ must be on the same cycle. **QED**.



